use solution::{opposites_solution, Set};

pub mod list_set;
pub mod solution;
pub mod tree_set;
pub mod utility;

fn main() {
    // let mut tree: tree_set::TreeSet<&str> = tree_set::TreeSet::new();
    // let mut list: list_set::ListSet<&str> = list_set::ListSet::new();
    // tree.insert(11);
    // tree.insert(1);
    // tree.insert(5);
    // tree.insert(12);
    // tree.insert(16);
    // tree.insert(11);
    // list.insert("cogito ergo sum");
    // tree.print();
    // list.print();
    // let test1 = vec![1, 2, 3];
    // let test2 = utility::explode("abcd".to_string());
    // let pre_suf = utility::prefixes_suffixes(test1);
    // let pre_suf = utility::prefixes_suffixes(test2);
    // println!("{:?}", pre_suf);
    // let binding = utility::read_file("words.txt".to_string());
    // let words = binding.split("\n").collect::<Vec<&str>>();
    // let output = opposites_solution(&mut tree, words);
    // println!("{:#?}", output);
    // let test = utility::possible_words::<String>("defect".to_string());
}
